This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: memory-bank/activeContext.md, memory-bank/productContext.md, memory-bank/progress.md, memory-bank/projectBrief.md, memory-bank/systemPatterns.md, memory-bank/techContext.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
memory-bank/
  activeContext.md
  productContext.md
  progress.md
  projectBrief.md
  systemPatterns.md
  techContext.md

================================================================
Files
================================================================

================
File: memory-bank/projectBrief.md
================
Snowscribe is a Novelwriting app. The elevator pitch is:

A novelwriting app that leverages AI throughout the process for brainstorming, outlining, editing, researching, identifying plot holes, coaching, and plot development. AI is never used for the final text, though.

The idea is that AI is such a great tool for all of दीन above, but too many current tools are based around using AI in the entire loop. My belief is that humans still need to be the ones writing while utilizing AI help them write the best novel they can.

## Basic Features

- Beautiful typography
- Clean, intuituve interface
- AI features that can be called from anywhere but also can fade into the background
- Great organization:
  - Chapters that hold scenes. Scenes hold the actual manuscript text.
  - Character cards that holds information about the characters.
  - World building/research notes that can hold information about the world of the novel itself.
  - Outlining tool to help the user outline the novel:
    - One-sentence synopsis (project's `log_line`).
    - One-page synopsis (project's `one_page_synopsis`).
    - Scene list with brief descriptions, POV character, other characters, and tags.
    - Scenes and chapters are shared between manuscript and outline views.
  - Project infomation that includes title, genre and total word count, along with a target total word count goal.
- Scenes can be tagged with what kind of scene it is.
- Scenes will also report what characters appear in them.
- Filtering and reporting capabilities (future enhancement).

## AI Features

- Snowflake Outliner
  - Helps the user outline their novel. Goes from the initial summary of the novel and keeps asking questions until they have a full outline. Can also help refine an existing outline or take rough notes and attempt to create an outline based on those notes.
- Character enhancer
  - Helps the user refine their characters. Help them name them. Help them create backstory. It does this by asking a lot of questions to help the writer flesh out the characters themselves. For example: instead of just deciding that a character lost their parents when they were a kid, the AI asks the writer what the character's childhood was like and what their parents were like. The AI helps keep the descriptions concise but useful.
- Research assistant
  - Helps the user research different topics, talk about different ways the world can work, helps with scientific questions, and helps compile everything into a world building "bible".
- Plot assistant
  - Helps identify plot holes in either the Outline stage or the manuscript stage. Takes a critical eye to the text to ask questions about character motivations, inconsistancies, etc.
  - Tries to assist the user to get out of "plot jams" when they write themselves into a corner, offering unique ideas on how to continue the plot.
  - Helps with plot in general, giving writers ideas on how they can make the plot more engaging, emotional, raise the stakes, etc.
- Writing coach
  - Gives the user feedback on their writing in general. How is the prose? Is it marketable? What are some areas they could look to improve?
  - The coach is helpful and positive but not sycophantic. It can give the writer hard truths when it needs to.
- Editor
  - Helps writers tighten up prose, offers suggestions
  - This assistant needs to walk the fine line of helping the writer with their own writing and not just do the writing for the writer

## Homepage UI/UX Detail

The main homepage (`app/page.tsx`, `HomePageClientWrapper.tsx`) displays a list of user's projects (`ProjectList.tsx`, `ProjectCard.tsx`) and allows creation of new projects via a modal (`CreateProjectModal.tsx`). It includes a header with navigation and user actions (`UserMenuButton.tsx`).

## Main App Dashboard UI/UX Detail

The main project screen (`app/(dashboard)/project/[projectId]/page.tsx` using `AppShell.tsx` and `ProjectDashboardClient.tsx`) is laid out like this:

### Top Header (`AppHeader.tsx`)

- Project name
- Genre
- Word count progress bar
- User menu

### Navigation Sidebar (`PrimarySidebar.tsx`)

- Manuscript
- Outline
- Characters
- World Building Notes
- AI Assistant
- Settings
- Export (Placeholder for now)

### Middle Column (Contextual List/Navigation within a section)

- **Manuscript**: Chapter list, drills down to Scene list.
- **Outline**: Navigation for "Synopsis" and "Scenes" views.
- **Characters**: List of characters (`CharacterList.tsx`).
- **World Building Notes**: List of notes (`WorldNoteList.tsx`).
- **AI Assistant**: (Future: List of AI tools or chat history).
- **Settings**: List of settings categories (e.g., AI Models, Vendors, Prompts).

### Main Detail Column (Editor/Content Area)

- **Manuscript**: Scene editor (`ManuscriptEditor.tsx`) for writing.
- **Outline**:
    - **Synopsis View**: `ProjectSynopsisEditor.tsx` for log_line and one-page synopsis.
    - **Scenes View**: `ChapterSceneOutlineList.tsx` displaying scenes with editable details (description, POV, characters, tags via modals).
- **Characters**: Character "card" editor (`CharacterCardEditor.tsx`).
- **World Building Notes**: Note editor (`WorldNoteEditor.tsx`).
- **AI Assistant**: `AISidePanel.tsx` providing an interface for specific AI tools (e.g., chat, tool execution with `AIToolButton`).
- **Settings**: Forms/lists for managing selected settings (e.g., `SettingsItemList.tsx` for AI Models).

## Technology Stack

- **NextJS 15.3.2** - React framework with server components
- **TypeScript** - Static typing for JavaScript
- **Tailwind CSS** - Utility-first CSS framework
- **Supabase** - Backend as a Service (auth, database, storage)
- **Fly.io** - Application hosting (Planned)
- **Docker** - Containerization (Planned)
- **Zod** - Form validation
- **snowgander (^0.0.36)** - Inhouse npm package for vendor agnostic AI API connectivity.
- **sonner** - Toast notifications.
- **React Hook Form** - For form management.
- **Lucide Icons** - Icon library.

## Design Principals

- Typography is king.
- Use the most modern UI/UX principals that exist.
- The app needs to look and feel polished.
- Clean interface that isn't too cluttered.
- Mobile responsiveness is absolutely required
- Should follow all modern accessibility web principles

## Business Model

The business model is mostly out of the scope of this document, but here are the basics:

- Freemium subscription model that gives all non-AI features for free and offers a small amount of AI credits for trial.
- Monthly and annual subscriptions for full access.
- Paid plans give generous AI access but will have a limit to prevent user use costs from outpacing income.

## AI Principals

- A large focus will be on creating strong system prompts for AI models (stored in `ai_prompts` table).
- Should give users a choice in AI models (managed via `ai_models` and `ai_vendors` tables, facilitated by `snowgander`).
- We need to be able to track AI costs internally and the ability to limit user AI usage based in on their subscription plan and their usage (Future implementation).

## Coding Principals

(As previously defined, emphasizing Server Components, TypeScript, component-driven design, Zod, `lib/data` abstraction, `lib/schema` for validation, and security best practices like `verifyProjectOwnership` guard and cookie forwarding for internal API calls.)

## Tech Stack Overview

(As previously defined)

================
File: memory-bank/productContext.md
================
# Product Context

## Purpose & Mission

Snowscribe is a novelwriting application that leverages AI throughout the creative process while ensuring human authors retain full creative control and authorship. The application aims to solve the problem where current AI writing tools take over too much of the writing process, while still providing powerful AI assistance for brainstorming, outlining, editing, researching, and plot development.

## Core Problem

Many current AI writing tools are built around AI generating the final text, removing human creativity and authorship from the process. Snowscribe believes that while AI is an excellent tool for supporting the writing process, humans should remain the actual authors of their novels.

## User Experience Goals

- Beautiful typography that enhances readability and aesthetics
- Clean, intuitive, modern, and polished interface that is uncluttered
- Mobile responsiveness is absolutely required
- Accessibility compliance with modern web standards
- Delightful user experience that makes the writing process enjoyable

## Key Features

### Organization

- **Project > Chapters > Scenes Structure**: Core manuscript organization is implemented.
- **Character Cards**: Functionality for creating, viewing, and editing character information is implemented.
- **World Building/Research Notes**: Section for creating, viewing, and editing world-building notes is implemented.
- **Outlining Tools**:
  - **Synopsis**: Project-level log line and one-page synopsis fields are available, with a dedicated editor UI (`ProjectSynopsisEditor`).
  - **Scene-Level Outlining**: Scenes can have an `outline_description`, a Point-of-View (`pov_character_id`) character, links to other characters involved (`other_character_ids`), and scene tags (`tag_ids`). A dedicated UI (`ChapterSceneOutlineList`) allows viewing and managing these details.
  - **Shared Manuscript & Outline Records**: Chapters and Scenes are the same records whether viewed in the manuscript or outline section, ensuring consistency.
- **Project Information**: Title, genre, word count tracking (current vs. target) are implemented.
- **Scene Tagging & Character Tracking**: Implemented with UI modals for managing tags and characters per scene.
- **Filtering and Reporting Capabilities**: Not yet implemented.

### AI Integration

- **AI Features Accessible**: AI tools are designed to be accessible (e.g., via `AISidePanel`, or AI Assistant buttons to update certain fields) but can fade into the background. For more detailed work, there is the `AISection` with several AI specific tools.
- **Specialized AI Tools**: The backend (`tool_model` table, `snowgander` integration via `lib/data/chat.ts`) and frontend (`AIToolButton`, `AISidePanel`) support the concept of specialized AI tools. Specific tools (e.g., scene helper) are being integrated.
- **List of AI Tools:**
  - Log line generator
  - One page synopsis generator
  - Scene analyzer
  - Outline generator (used one page synopsis to generate an outline and characters)
  - Character description/backstory generator
  - Character chat (chat with an AI that is impersonating a character)
  - Plot hole analyzer
  - Notes / World Building helper
  - Writing Coach (general, not project specific)
  - Manuscript chat (uses the entire manuscript as context)
  - Outline chat (uses the outline, descriptions, and characters as context)
- **AI Never Generates Final Manuscript Text**: This remains a core design principle.
- **Types of AI Interfaces:**
  - Multi-turn chats
  - Single turn chats (a button sends a prompt and we get a reply without the ability to continue the chat)
  - "Generate Using AI" buttons (single buttons that populate a field)
  - The outline generator is an advanced tool that does agentic work to create an entire outline and characters.

## Business Model

- Freemium subscription model
- Free tier includes all non-AI features plus limited AI credits
- Monthly and annual subscriptions for full access
- Paid plans have generous but limited AI access to control costs

================
File: memory-bank/systemPatterns.md
================
```
├── app/                    # Next.js App Router structure
│   ├── (auth)/             # Authentication routes (grouped)
│   ├── (dashboard)/        # Dashboard routes (grouped)
│   ├── api/                # API routes
│   ├── globals.css         # Global styles
│   └── layout.tsx          # Root layout
├── components/             # React components
│   ├── dashboard/          # Project dashboard section components (sections/ManuscriptSection, sections/OutlineSection, etc.)
│   │   └── sections/       # Modular dashboard section components (ManuscriptSection, OutlineSection, CharactersSection, WorldNotesSection)
│   ├── ui/                 # Reusable UI components
│   ├── auth/               # Auth-specific components
│   ├── editors/            # Manuscript, Character, Note editors
│   ├── homepage/           # Components for the main landing/project list page
│   ├── layouts/            # Layout components (AppShell, Sidebars, etc.)
│   ├── manuscript/         # Chapter/Scene list and creation modals
│   ├── characters/         # Character list and creation modal
│   ├── world-notes/        # World note list and creation/edit components
│   ├── outline/            # Outline specific components
│   ├── ai/                 # AI interaction components (AISidePanel, AIToolButton, AIChatInterface)
│   └── settings/           # Settings page components
├── lib/                    # Shared utilities
│   ├── supabase/           # Supabase client, middleware, guards, database types
│   ├── utils/              # General utilities (cn, countWords, etc.)
│   ├── schemas/            # Zod schemas for validation
│   ├── data/               # Data access layer (functions calling internal APIs)
│   ├── types/              # TypeScript types and interfaces
│   └── fonts.ts            # Font configurations
├── hooks/                  # Custom React hooks
│   └── dashboard/          # Section-specific data hooks (useManuscriptData, useCharactersData, etc.)
├── middleware.ts           # Next.js middleware for auth session handling
└── public/                 # Static assets
```

## Key Technical Decisions

### Outline Creator Implementation (2025-05-29)

- **AI Integration**: Uses `AISMessageHandler` to interact with AI models via the `outline_json_generator` tool
- **JSON Schema Validation**: Strict TypeScript interfaces define the expected output structure
- **Two-Phase Process**:
  1. `generateAndParseOutline` - Calls AI and validates JSON response
  2. `createEntitiesFromOutline` - Creates database entities from parsed data
- **Entity Creation**:
  - Creates characters, chapters, scenes with proper relationships
  - Handles scene tags and character associations
  - Maintains order and structure from the AI-generated outline
- **Error Handling**: Robust validation and error recovery at each step
- **UI Integration**: Modal-based workflow in OutlineSection with progress feedback

### AI Tool Integration Pattern (2025-05-30)

- **Tool Mapping**: AI tools are mapped to specific models via the `tool_model` table
- **Prompt Management**: Tools use prompts from the `ai_prompts` table, allowing for customization
- **UI Components**:
  - `AIToolButton` triggers tool execution
  - `AISidePanel` displays tool interface and responses
  - `MultiTurnChatInterface` handles conversational tools
- **Response Handling**:
  - Structured data responses are parsed and used to create entities
  - Free-form responses are displayed as Markdown
- **Error Handling**: Robust validation of AI outputs using Zod schemas

## Key Technical Decisions

1.  **Server Components by Default**: Using React Server Components for improved performance, SEO, and reduced client-side JavaScript.
2.  **Client Components When Necessary**: Adding `"use client"` directive only for components that require interactivity, hooks, or browser APIs.
3.  **Strong Type System**: Strict TypeScript typing for all components, functions, and data structures, largely inferred from Zod schemas and Supabase types.
4.  **Component-Driven Design**: Building a library of reusable, single-responsibility UI components in `components/ui` and feature-specific components.
5.  **Supabase for Backend Services**: Using Supabase for authentication, PostgreSQL database, and potentially storage.
6.  **AI Integration via `snowgander`**: Utilizing the `snowgander` package for vendor-agnostic AI API connectivity.
7.  **API-Driven Data Layer**: Frontend components (both server and client) interact with internal Next.js API Route Handlers via functions in `lib/data/*`. These API routes then communicate with Supabase.
8.  **Two-Tiered Scene Tag System (2025-05-25)**: Scenes have a `primary_category` (ENUM) column for main classification and are linked to multiple global tags via a join table (`scene_applied_tags`). Tag management is handled through dedicated API routes and UI, not as direct columns on the scene.
9.  **Modular Dashboard Architecture (2025-05-26)**: The project dashboard is now fully modular. Each section (Manuscript, Outline, Characters, World Notes) is implemented as a self-contained component in `components/dashboard/sections/`, using its own custom data hook in `hooks/dashboard/`. Shared project-wide data (e.g., all characters, all scene tags) is managed by `ProjectDataContext`, providing context and hooks to all sections. All state, effects, and handlers have been removed from `ProjectDashboardClient.tsx`, which now simply renders the section components and provides context. This enables easier testing, maintenance, and future feature development.

## Design Patterns

### View/Edit Toggle Pattern for Note-like Features (2025-05-26)

- For features involving user-authored notes (e.g., World Notes), the UI defaults to a static, Markdown-rendered viewer with an explicit "Edit" button.
- View/edit state is managed in the relevant data hook (e.g., `isEditingSelectedNote`, `enableEditMode`, `disableEditMode` in `useWorldNotesData`).
- The main section component conditionally renders either the viewer or the editor based on this state, using distinct React keys to ensure proper remounting.
- The editor includes a "Cancel" button and ensures edits are only applied when explicitly saved.
- This pattern improves UX clarity, prevents accidental edits, and provides a clean, readable display for notes.
- The approach is designed for extension to other note-like features (e.g., character bios, research notes) for consistency.

### Component Design Pattern

- Using the **Variant Pattern** with `class-variance-authority` (CVA) for creating flexible, variant-driven UI components (e.g., `Button.tsx`).
- Following the **Single Responsibility Principle** (SRP) for all components.
- Adopting an **Atomic Design**-inspired methodology: `components/ui` for atoms/molecules, feature-specific components for organisms.

### State Management Pattern

- **Server-First State Management**: Keeping as much state as possible on the server, fetched by Server Components or API routes.
- **Local Component State**: Using React's `useState` and `useReducer` for component-specific UI state in Client Components.
- **URL State**: Utilizing URL parameters for managing view states where appropriate (e.g., `projectId`, `activeSection` in dashboard).

### Data Fetching Pattern

- **Server Components**: Direct data fetching in Server Components by calling functions from `lib/data/*` which in turn call internal APIs.
- **Client Components**: Fetching data via functions in `lib/data/*` (which call internal APIs) typically within `useEffect` hooks or triggered by user interactions. `ProjectDashboardClient.tsx` exemplifies this for dynamic content like chapters, scenes, characters, etc.
- **API Routes**: Next.js Route Handlers in `app/api/` serve as the backend, processing requests from `lib/data/*` functions and interacting with Supabase.

### Authentication Pattern

- **Core**: Utilizes Supabase Auth with server-side session handling via `@supabase/ssr` and cookie management.
- **Route Protection**:
  - **Middleware (`middleware.ts`)**: Protects routes by validating user sessions. Unauthenticated users are redirected to `/login`.
  - **API Route Authorization**:
    - All API routes verify the authenticated user via `supabase.auth.getUser()`.
    - Project-specific routes (e.g., `/api/projects/[projectId]/...`) use the `verifyProjectOwnership` guard from `lib/supabase/guards.ts` to ensure the user owns the project before proceeding.
- **Database Level Security (RLS)**: Supabase RLS policies enforce data access rules at the database level, complementing application-level checks.

### Data Management and Validation Patterns

- **Entity-Specific Zod Schemas (`lib/schemas`)**: Each core data entity has a Zod schema for input validation at API boundaries and type inference.
- **Centralized Data Access Layer (`lib/data`)**: Server-side functions in `lib/data/*` abstract API calls, providing a consistent interface for data operations. These functions handle cookie forwarding for authenticated requests to internal APIs.
- **Project Ownership Guard (`lib/supabase/guards.ts`)**: A utility function, `verifyProjectOwnership`, centralizes project access authorization logic.
- **Scene Tag Management**: Scene tags are managed via a join table (`scene_applied_tags`) and dedicated API routes/components, not as a direct column on the `scenes` table. The `primary_category` is an ENUM field on scenes, while additional tags are assigned through the join table for flexible, multi-tag support.

### AI Configuration Data Model

To support `snowgander` and manage AI settings:

- **`ai_vendors`**: Stores AI API providers (e.g., OpenAI, Anthropic). Key fields: `name`, `api_key_env_var`.
- **`ai_models`**: Stores configurations for specific AI models. Key fields: `vendor_id`, `name`, `api_name`, capabilities (`is_vision`, `is_image_generation`, `is_thinking`), cost/token info.
- **`ai_prompts`**: Stores reusable prompts (global, user-specific, or project-specific). Key fields: `project_id`, `user_id`, `name`, `prompt_text`, `category`. Unique constraint on `(COALESCE(project_id, <UUID_ZERO>), COALESCE(user_id, <UUID_ZERO>), name)`.
- **`tool_model`**: Maps a tool name (e.g., "scene_helper") to a specific `ai_models.id`. Key fields: `name` (unique), `model_id`.
- **RLS**: Generally, authenticated users can read AI configurations. Management (create, update, delete) is typically restricted (e.g., to admins or via specific logic if user-configurable items are introduced), though current RLS for `ai_models` and `tool_model` allows authenticated users all access, which might need refinement. Prompts have more granular user/project ownership RLS.

## Component Relationships

### Core Component Structure (Illustrative)

```mermaid
graph TD
    Layout[Root Layout: app/layout.tsx] --> HomePage[Homepage: app/page.tsx & HomePageClientWrapper]
    Layout --> LoginPage[Login Page: app/(auth)/login/page.tsx]
    Layout --> DashboardLayout[Dashboard Layout: app/(dashboard)/layout.tsx]

    DashboardLayout --> ProjectPage[Project Page: app/(dashboard)/project/[projectId]/page.tsx]
    ProjectPage --> AppShell[AppShell]
    AppShell --> PrimarySidebar[PrimarySidebar]
    AppShell --> AppHeader[AppHeader]
    AppShell --> ProjectDashboardClient[ProjectDashboardClient]
    ProjectDashboardClient --> ManuscriptSection
    ProjectDashboardClient --> OutlineSection
    ProjectDashboardClient --> CharactersSection
    ProjectDashboardClient --> WorldNotesSection

    ManuscriptSection --> CreateChapterModal
    ManuscriptSection --> CreateSceneModal
    ManuscriptSection --> ManuscriptEditor
    ManuscriptSection --> SceneMetadataPanel
    ManuscriptSection --> AISidePanel

    OutlineSection --> ProjectSynopsisEditor
    OutlineSection --> ChapterSceneOutlineList
    ChapterSceneOutlineList --> ManageSceneCharactersModal
    ChapterSceneOutlineList --> ManageSceneTagsModal

    CharactersSection --> CharacterList
    CharactersSection --> CreateCharacterModal
    CharactersSection --> CharacterCardEditor

    WorldNotesSection --> WorldNoteList
    WorldNotesSection --> CreateWorldNoteModal
    WorldNotesSection --> WorldNoteEditor

    AISidePanel --> AIToolButton
    AISidePanel --> AIChatInterface

    DashboardLayout --> SettingsPage[Settings Page: app/(dashboard)/settings/page.tsx]
    SettingsPage --> SiteSettingsClient[SiteSettingsClient]
    SiteSettingsClient --> SettingsItemList[SettingsItemList for AI Models]
    SiteSettingsClient --> CreateAIModelModal
    SiteSettingsClient --> EditAIModelModal
    SiteSettingsClient --> AlertDialog[AlertDialog for Deletion]

```

### Data Flow

```mermaid
graph TD
    Browser[User Interaction in Client Component] -->|Triggers Action| ClientComponentLogic[Client Component Logic e.g., ProjectDashboardClient]
    ClientComponentLogic -->|Calls lib/data function| LibDataFunction[lib/data/* function]
    LibDataFunction -->|fetch (with cookies)| InternalAPI[app/api/* Route Handler]
    InternalAPI -->|Verifies Auth & Ownership (Guard)| SupabaseGuard[verifyProjectOwnership]
    InternalAPI -->|Validates Input (Zod)| ZodValidation[Zod Schema]
    InternalAPI -->|Database Query (Supabase Client)| SupabaseDB[Supabase Database (PostgreSQL)]
    InternalAPI -->|AI Request (snowgander)| Snowgander[snowgander Lib -> External AI Service]

    SupabaseDB -->|Returns Data| InternalAPI
    Snowgander -->|Returns AI Response| InternalAPI
    InternalAPI -->|JSON Response| LibDataFunction
    LibDataFunction -->|Returns Data/Promise| ClientComponentLogic
    ClientComponentLogic -->|Updates UI State (useState, etc.)| Browser

    ServerComponent[Server Component e.g., app/page.tsx] -->|Calls lib/data function| LibDataFunction
    %% Server components can also directly call Supabase client if not using API abstraction
    %% ServerComponent -->|Direct Supabase Query| SupabaseDB
```

## Critical Implementation Paths

### Authentication Flow

1.  User navigates to a page. Middleware (`middleware.ts` using `lib/supabase/middleware.ts`) intercepts.
2.  Session is checked/refreshed using `@supabase/ssr`.
3.  If no valid session and route is protected, redirect to `/login`.
4.  Login/Signup via `AuthForm` component, which calls server actions in `app/(auth)/login/actions.ts`.
5.  Actions interact with Supabase Auth. On success, Supabase sets cookies.
6.  Callback route (`app/(auth)/auth/callback/route.ts`) handles OAuth/email confirmation, exchanges code/token for session.
7.  Logout via POST to `app/(auth)/auth/logout/route.ts`.

### Project Data Interaction (e.g., Editing a Scene)

1.  User types in `ManuscriptEditor` (Client Component within `ProjectDashboardClient`).
2.  Debounced `handleSaveSceneContent` in `ProjectDashboardClient` is triggered.
3.  `handleSaveSceneContent` calls `fetch` to the PUT endpoint: `/api/projects/[projectId]/chapters/[chapterId]/scenes/[sceneId]`.
4.  The API route handler:
    a. Verifies user authentication.
    b. Uses `verifyProjectOwnership` guard to check project access.
    c. Validates request body with `updateSceneSchema` (Zod).
    d. Updates the scene in Supabase database.
    e. Returns the updated scene data.
5.  `ProjectDashboardClient` updates its local state with the new scene data, re-rendering `ManuscriptEditor`.

### AI Tool Usage

1.  User clicks an `AIToolButton` within `AISidePanel`.
2.  `AIToolButton` calls `chat` function from `lib/data/chat.ts`, passing model ID, prompt, system prompt.
3.  `lib/data/chat.ts`:
    a. Fetches `AIModel` and `AIVendor` details.
    b. Creates `ModelConfig` for `snowgander`.
    c. Gets `AIVendorAdapter` from `AIVendorFactory`.
    d. Calls `adapter.sendChat()` with current chat context.
4.  `snowgander` handles the call to the external AI service.
5.  Response is returned to `AIToolButton`, then to `AISidePanel`, which updates its state to display the response (e.g., using `MarkdownComponent`).

================
File: memory-bank/techContext.md
================
# Technical Context

## Technology Stack

Snowscribe is built with a modern frontend-focused stack:

| Technology                       | Purpose                                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------------------- |
| **Next.js 15.3.2**               | React framework with server components                                                       |
| **React 19**                     | JavaScript library for building user interfaces                                              |
| **TypeScript**                   | Static typing for JavaScript                                                                 |
| **Tailwind CSS 4**               | Utility-first CSS framework                                                                  |
| **Supabase**                     | Backend as a Service (auth, database, storage)                                               |
| **PostgreSQL ENUM + Join Table** | Scene primary category as ENUM, global tags via join table                                   |
| **Fly.io**                       | Application hosting (Planned)                                                                |
| **Docker**                       | Containerization (Planned)                                                                   |
| **Zod**                          | Schema declaration and validation                                                            |
| **snowgander (^0.0.36)**         | In-house package for vendor-agnostic AI API connectivity                                     |
| **sonner**                       | Toast notifications                                                                          |
| **React Hook Form**              | Form management and validation integration                                                   |
| **Lucide Icons**                 | Icon library                                                                                 |
| **Radix UI Primitives**          | Base for accessible UI components (Dropdown, Tooltip, Separator, AlertDialog)                |
| **React Markdown / Remark GFM**  | For rendering Markdown content (e.g., AI responses, note editors, World Notes static viewer) |
| **React Syntax Highlighter**     | For syntax highlighting in Markdown code blocks                                              |

## Shared Types Definition

A central file `lib/types/index.ts` defines shared TypeScript interfaces for data structures used throughout the application, derived from Supabase table schemas and UI requirements. This ensures type consistency between the frontend and backend.

- The dashboard is now fully modular: each section (Manuscript, Outline, Characters, World Notes) is implemented as a self-contained component in `components/dashboard/sections/`, using its own custom data hook in `hooks/dashboard/`. Shared project-wide data (e.g., all characters, all scene tags) is managed by `ProjectDataContext`, providing context and hooks to all sections. All state, effects, and handlers have been removed from `ProjectDashboardClient.tsx`, which now simply renders the section components and provides context.

The content of `lib/types/index.ts` includes interfaces such as `Project`, `Genre`, `Profile`, `Chapter`, `Scene`, `SceneTag`, `SceneAppliedTag`, `Character`, `SceneCharacter`, `WorldBuildingNote`, `AIInteraction`, `AIVendor`, `AIModel`, and `AIPrompt`.

- The `Scene` and `SceneTag` types now reflect the two-tiered tag system: `primary_category` (ENUM) and an array of tag IDs (via join table).

## `lib/schemas` Directory Pattern

The `lib/schemas/` directory houses Zod schema definitions for the application's core data entities.

- **Pattern**: Each primary data entity (e.g., `Project`, `Chapter`, `Scene`, `Character`, `WorldBuildingNote`, `AIVendor`, `AIModel`, `AIPrompt`, `ToolModel`) has its own dedicated schema file.
- **Purpose**:
  - **API Input Validation**: Used in API Route Handlers to validate incoming request bodies.
  - **Type Inference**: Zod schemas allow for easy inference of TypeScript types.
  - **Centralized Validation Logic**: Consolidates validation rules.
  - **Form Validation**: Used with `React Hook Form` (via `@hookform/resolvers/zod`) for client-side form validation.
  - **Scene Tag System**: Scene and tag schemas validate `primary_category` (ENUM) and arrays of tag IDs for join-table-based tagging.

## `lib/data` Directory Pattern

The `lib/data/` directory contains server-side functions responsible for data fetching and manipulation, acting as a dedicated data access layer.

- **Pattern**: Files within this directory (e.g., `projects.ts`, `chapters.ts`, `aiModels.ts`) export asynchronous functions. These functions typically make `fetch` calls to internal API Route Handlers located in `app/api/`.
- **Purpose**:
  - **API Abstraction**: Abstracts the direct `fetch` calls to internal APIs, providing a cleaner interface for Server Components and other server-side logic.
  - **Reusability**: These functions are used by React Server Components and can also be used by other server-side modules if needed.
  - **Separation of Concerns**: Keeps data fetching/mutation logic separate from UI components.
  - **Server-Side Logic**: Ensures that interactions with the backend APIs are handled on the server where appropriate.
  - **Cookie Forwarding**: Implements logic to forward authentication cookies for internal API calls.

## AI Implementation Guidelines

- **System Prompts:** Invest significant effort in crafting clear, specific, and robust system prompts for each AI feature to ensure high-quality, targeted assistance.
- **AI Model Flexibility:** Utilize the `snowgander` package to allow for potential user choice in AI models and for easier backend model management.
- **Usage & Cost Control:** Implement mechanisms to track AI usage per user and enforce limits based on subscription tiers. This is critical for business viability.
- **Specific AI Feature Reminders:**
  - **Snowflake Outliner:** Guide users from summary to full outline via iterative questioning.
  - **Character Enhancer:** Use Socratic questioning to help writers deepen character backstories and motivations.
  - **Research Assistant:** Facilitate research and compile information into a "world-building bible."
  - **Plot Assistant:** Identify plot holes, suggest resolutions for "plot jams," and offer ideas to enhance engagement.
  - **Writing Coach:** Provide constructive, honest feedback on prose and marketability.
  - **Editor:** Suggest prose improvements without rewriting. The line between assisting and writing is crucial here.
  - **Outline Creator:** Generate structured novel outlines with character relationships and scene tags using JSON schema validation.
  - **Character Chat:** Chat with any of the characters from the novel. It sends every scene a character is in as context

## Development Setup

### Required Tools

- Node.js 20+
- npm/pnpm/yarn
- Git
- Docker (for local development and production builds - Planned)
- Supabase CLI (for local development and migrations)
  - Supabase migrations and seed scripts are used to define ENUMs (for scene primary category) and to seed global scene tags.

### Environment Variables (Example)

```
# Next.js
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Supabase
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-supabase-service-role-key # For admin tasks, migrations

# AI Services (for snowgander, specific keys depend on vendor)
OPENAI_API_KEY=your-openai-api-key
ANTHROPIC_API_KEY=your-anthropic-api-key
GOOGLE_API_KEY=your-google-api-key
OPENROUTER_API_KEY=your-openrouter-api-key
# etc.
```

## Outline Creator Technical Details

The Outline Creator feature provides automated novel outline generation with:

- **AI JSON Generation**: Uses `outline_json_generator` tool via `AISMessageHandler`
- **Structured Types**: Defined in `lib/types/ai.ts` with ParsedOutlineData interface
- **Two-Phase Process**:
  1. AI interaction and JSON parsing via `generateAndParseOutline`
  2. Database entity creation via `createEntitiesFromOutline`
- **Entity Relationships**: Handles character-scene connections, chapter ordering
- **Error Handling**: Robust validation of AI output before database operations

## Technical Constraints

### Supabase Auth SSR

- Uses `@supabase/ssr` package.
- Implements cookie handling with `getAll()` and `setAll()` methods.
- Separate browser (`lib/supabase/client.ts`) and server (`lib/supabase/server.ts`) clients.
- Middleware (`middleware.ts` and `lib/supabase/middleware.ts`) for session refresh and route protection.

### Mobile Responsiveness

- UI components designed with responsiveness in mind using Tailwind CSS.
- Ongoing effort to ensure usability across screen sizes.

### Accessibility Requirements

- Adherence to WCAG 2.1 AA standards is a goal.
- Use of semantic HTML and ARIA attributes where appropriate.
- Keyboard navigation and screen reader compatibility are considerations.

## Dependencies and Tooling

This section details the project's key dependencies and development tools, as defined in `package.json`.

### Core Dependencies (`dependencies`)

| Package                         | Version    | Purpose                                                                |
| ------------------------------- | ---------- | ---------------------------------------------------------------------- |
| `@hookform/resolvers`           | `^5.0.1`   | Zod resolver for React Hook Form.                                      |
| `@radix-ui/react-alert-dialog`  | `^1.1.13`  | Unstyled, accessible alert dialog primitive.                           |
| `@radix-ui/react-dropdown-menu` | `^2.1.14`  | Unstyled, accessible dropdown menu primitive.                          |
| `@radix-ui/react-separator`     | `^1.1.6`   | Unstyled, accessible separator primitive.                              |
| `@radix-ui/react-slot`          | `^1.2.2`   | Utility to compose component props.                                    |
| `@radix-ui/react-tooltip`       | `^1.2.6`   | Unstyled, accessible tooltip primitive.                                |
| `@supabase/ssr`                 | `^0.6.1`   | Supabase helpers for Server-Side Rendering in Next.js.                 |
| `@supabase/supabase-js`         | `^2.49.4`  | Official Supabase JavaScript client library.                           |
| `class-variance-authority`      | `^0.7.1`   | Library for creating type-safe, variant-driven UI components (CVA).    |
| `clsx`                          | `^2.1.1`   | Utility for constructing `className` strings conditionally.            |
| `lucide-react`                  | `^0.509.0` | Library of open-source icons.                                          |
| `next`                          | `15.3.2`   | The React framework for production.                                    |
| `react`                         | `^19.0.0`  | JavaScript library for building user interfaces.                       |
| `react-dom`                     | `^19.0.0`  | Entry point to the DOM and server renderers for React.                 |
| `react-hook-form`               | `^7.56.3`  | Performant, flexible and extensible forms with easy-to-use validation. |
| `react-markdown`                | `^10.1.0`  | React component to render Markdown.                                    |
| `remark-gfm`                    | `^4.0.1`   | Remark plugin for GitHub Flavored Markdown.                            |
| `snowgander`                    | `^0.0.36`  | In-house package for vendor-agnostic AI API connectivity.              |
| `sonner`                        | `^2.0.3`   | Opinionated toast component for React.                                 |
| `tailwind-merge`                | `^2.6.0`   | Utility to merge Tailwind CSS classes without style conflicts.         |
| `zod`                           | `^3.24.4`  | TypeScript-first schema declaration and validation library.            |

### Development Dependencies (`devDependencies`)

| Package                           | Version    | Purpose                                                      |
| --------------------------------- | ---------- | ------------------------------------------------------------ |
| `@eslint/eslintrc`                | `^3`       | ESLint configuration utilities.                              |
| `@tailwindcss/forms`              | `^0.5.10`  | Tailwind CSS plugin for basic form styling.                  |
| `@tailwindcss/postcss`            | `^4`       | PostCSS plugin for Tailwind CSS.                             |
| `@tailwindcss/typography`         | `^0.5.16`  | Tailwind CSS plugin for beautiful typographic defaults.      |
| `@types/node`                     | `^20`      | TypeScript definitions for Node.js.                          |
| `@types/react`                    | `^19`      | TypeScript definitions for React.                            |
| `@types/react-dom`                | `^19`      | TypeScript definitions for React DOM.                        |
| `@types/react-syntax-highlighter` | `^15.5.13` | TypeScript definitions for react-syntax-highlighter.         |
| `eslint`                          | `^9`       | Pluggable linting utility for JavaScript and JSX.            |
| `eslint-config-next`              | `15.3.2`   | ESLint configuration for Next.js projects.                   |
| `react-syntax-highlighter`        | `^15.6.1`  | Syntax highlighting component for React, used with Markdown. |
| `tailwindcss`                     | `^4`       | A utility-first CSS framework for rapid UI development.      |
| `typescript`                      | `^5`       | Superset of JavaScript that adds static types.               |

### Internal Packages

- **snowgander (`^0.0.36`)**: As listed in dependencies, this is our in-house package for vendor-agnostic AI API connectivity. It provides:
  - Unified API for multiple AI providers (OpenAI, Anthropic, Google, OpenRouter currently have API key env vars).
  - Token usage tracking (planned/potential).
  - Rate limiting (planned/potential).
  - System prompt management abstraction (model configuration can include prompts).
  - Context window optimization (planned/potential).

## Tool Usage Patterns

### Supabase Usage

- Browser client (`lib/supabase/client.ts`): For client-side components.
- Server client (`lib/supabase/server.ts`): For Server Components and API Routes, using cookie store.

### Tailwind CSS with CVA

- UI components (`components/ui/*`) extensively use `class-variance-authority` for defining variants (e.g., `Button.tsx`, `Heading.tsx`).
- `cn` utility (`lib/utils.ts`) combines `clsx` and `tailwind-merge` for conditional and clean class names.

### Server Component Data Fetching

- Server Components (e.g., `app/page.tsx`, `app/(dashboard)/project/[projectId]/page.tsx`) fetch data by calling async functions from `lib/data/*`. These functions, in turn, make `fetch` requests to internal API routes.

```typescript
// Example: app/(dashboard)/project/[projectId]/page.tsx
import { getProjectById } from "@/lib/data/projects";

export default async function ProjectPage({
  params,
}: {
  params: { projectId: string };
}) {
  const project = await getProjectById(params.projectId);
  // ... use project data
}
```

### Zod Validation

- Schemas in `lib/schemas/*` are used:
  - In API Route Handlers for validating request bodies.
  - With `React Hook Form` (via `@hookform/resolvers/zod`) for client-side form validation in modals (e.g., `CreateProjectModal.tsx`, `CreateAIModelModal.tsx`).

### Server-Side Internal API Calls & Cookie Forwarding

- Functions in `lib/data/*` make `fetch` requests to internal API routes (`app/api/*`).
- Authentication cookies are explicitly read using `cookies()` from `next/headers` and forwarded in the `Cookie` header of these `fetch` requests to ensure authenticated context.

### Authorization Utilities (`lib/supabase/guards.ts`)

- **`verifyProjectOwnership` Guard**: Used in project-specific API routes to check if the authenticated user owns the project before allowing operations.

================
File: memory-bank/progress.md
================
# Project Progress

_(Updated: 2025-05-26 (AI-Generated Update))_

## What Works

- **Outline Creator (2025-05-30):**

  - Generates structured novel outlines from a synopsis
  - Creates characters, chapters, and scenes in the database
  - Handles scene tags and character associations
  - Includes robust error handling and validation

- **World Notes Static Viewer & Edit Toggle (2025-05-26):**

  - The World Notes section now displays notes in a static, Markdown-rendered view by default, with an "Edit" button to switch to the editor.
  - View/edit state is managed in `useWorldNotesData` with new state and handlers.
  - The new `WorldNoteViewer` component provides a clean, readable Markdown display, visually distinct from the editor.
  - The main section conditionally renders the viewer or editor, ensuring seamless transitions and correct state resets on selection or deletion.
  - The editor now supports a "Cancel" button and improved save/cancel flow.
  - All flows (view, edit, create, delete, edge cases) have been tested for correctness and UX clarity.
  - This pattern may be extended to other note-like features for improved consistency.

- **Major Project Dashboard Refactor (2025-05-26):**

  - The dashboard is now fully modular: each section (Manuscript, Outline, Characters, World Notes) is implemented as a self-contained component in `components/dashboard/sections/`, using its own custom data hook in `hooks/dashboard/`.
  - Shared project-wide data (e.g., all characters, all scene tags) is managed by `ProjectDataContext`, providing context and hooks to all sections.
  - All state, effects, and handlers have been removed from `ProjectDashboardClient.tsx`, which now simply renders the section components and provides context.
  - All modals and detail panels are managed within their respective section components.
  - The new structure enables easier testing, maintenance, and future feature development.
  - Comprehensive cleanup and bugfixes: removed unused variables/imports, fixed all TypeScript errors, audited all `useEffect`/`useCallback` dependencies, and verified all import paths.
  - Fixed key bugs: infinite character query loop in OutlineSection, real-time word count update in `AppHeader`, and optional character image handling in `CreateCharacterModal`.
  - All dashboard sections and flows have been tested for CRUD, navigation, and data consistency.

<!-- (rest of file unchanged) -->

## What's Left to Build

### Core Infrastructure

- [ ] Authentication System:
  - [ ] Refined error handling and user feedback (e.g., consistent `sonner` toasts for all auth actions).
- [ ] User Profile Management:
  - [ ] UI for users to view/edit their profile information.
  - [ ] UI for changing password (distinct from password reset).

### Main Features

- [ ] Project Management (Client-Side):
  - [x] Project editing interface (e.g., update title, genre, target word count).
  - [x] Project deletion confirmation and functionality from homepage/dashboard.
- [ ] Outlines (Client-Side Enhancements):
  - [ ] More robust editing experience within `ChapterSceneOutlineList.tsx` (e.g., inline editing or more comprehensive modals for all scene outline fields).
  - [ ] UI for reordering scenes within chapters, and chapters within the project.
  - [ ] UI to fully demonstrate/facilitate the Snowflake method (if specific UI beyond synopsis fields is needed).
- [ ] World Building & Research Notes (Enhancements):
  - [x] Static Markdown viewer and edit toggle for World Notes.
  - [ ] Advanced Notes organization UI (e.g., filtering/searching by category).
  - [ ] Linking notes to specific manuscript scenes or characters.
- [ ] Export Functionality:
  - [ ] Implement project export (e.g., as a manuscript format).
- [ ] Scene Tag System:
  - [ ] Finalize dedicated tag management UI and API routes.
  - [ ] Comprehensive testing and UX refinement for the new two-tiered tag system.

### AI Features

- [ ] AI Service Integration:
  - [ ] Token tracking and usage limits per user (requires backend and UI).
- [ ] Specific AI Tools Implementation:
  - [x] **Snowflake Log Line Outliner**: Integrate AI to assist with one-sentence synopses based on user input or existing project content. (Log line generation refactored to background modality).
  - [x] **Snowflake Synopsis Outliner**: Integrate AI to assist with one-page synopses based on user input or existing project content.
  - [ ] **Snowflake Scene Outliner**: Integrate AI to assist with generating a summary of the scene based on the scene text.
  - [ ] **Character Enhancer**: Develop prompts and UI for AI to help flesh out characters.
  - [ ] **Research Assistant**: Tool for AI-powered research within the app.
  - [ ] **Plot Assistant**: Tools for identifying plot holes, brainstorming plot points.
  - [ ] **Writing Coach**: AI feedback on writing style, prose.
  - [ ] **Editor Assistant**: AI suggestions for tightening prose (respecting "AI never writes final text" principle).
- [ ] AI Settings Expansion:
  - [ ] UI in `SiteSettingsClient.tsx` for managing AI Prompts (CRUD), potentially with categorization.

### Deployment & DevOps

- [ ] Docker Setup (Development and Production).
- [ ] CI/CD Pipeline (Testing, Build, Deployment).
- [ ] Fly.io Deployment (Configuration, Domain, SSL).

## Current Status

### Outline Creator (2025-05-30)

✅ JSON structure and interfaces  
✅ System prompt configuration  
✅ Backend logic for AI interaction  
✅ Entity creation from outline  
✅ UI implementation in OutlineSection  
✅ Comprehensive testing with various synopses  
✅ Prompt refinement based on testing  
🔧 User feedback collection

## Current Status

**Phase**: Foundational AI Integration & Outline UI Implemented -> **Focusing on Expanding Specific AI Tools, Completing Outline/Settings UI, Scene Tag System Overhaul, and AI Prompts Management**

The project has a robust backend API, a functional authentication system, and a well-structured frontend with key dashboard sections (Manuscript, Characters, World Notes, basic Outline, AI Model, Vendor & Prompt Settings) implemented. `snowgander` is integrated for AI calls, and the log line generation feature now operates in a background modality. The "Edit Project Details" modal has been successfully implemented, allowing users to update core project information.

The immediate focus areas are:

1.  **Flesh out AI Tools**: Implement specific AI assistance features (beyond log line generation) using the established `AISidePanel` and `AIToolButton` pattern, leveraging `tool_model` and `ai_prompts`.
2.  **Complete Outline UI**: Enhance the scene outline editing capabilities and consider chapter/scene reordering.
3.  **Complete AI Settings UI**: Add management for AI Prompts.
4.  **Scene Tag System**: Finalize and test the new two-tiered tag system (primary category + global tags), including dedicated tag management UI/API and comprehensive UX testing.
5.  **User Profile Management**: Basic profile page.
6.  **Refine UX & Error Handling**: Improve user feedback across the application.

## Known Issues

- Client-side error handling for some data operations could be more robust with `sonner` toasts.
- Full word count aggregation for chapters/project is present in API responses but might need more prominent UI display beyond `AppHeader`.
- AI Tool specific system prompts need to be created and managed.
- The UI needs a lot of refinement and polish.

### Bugs

- [Fixed 2025-05-26] When no characters exist in a project, the app kept querying characters over and over non-stop when on the outline page (OutlineSection infinite query loop). **Resolved by tracking fetch attempts per project.**
- [Fixed 2025-05-26] The total project word count did not get updated in real time, only after a refresh. **Resolved by calling `router.refresh()` after scene edits.**
- [Fixed 2025-05-26] The optional character image was incorrectly set up as required. **Resolved by handling `image_url` as nullable/optional in `CreateCharacterModal`.**

## Evolution of Project Decisions

| Date                       | Decision                                                                                                                                                                                                                                                                           | Rationale                                                                                                                                           |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2025-05-26 (AI Update)     | Adopted a static Markdown viewer with edit toggle for World Notes, managed by explicit view/edit state in the data hook and conditional rendering in the section component.                                                                                                        | To improve UX clarity, prevent accidental edits, and provide a clean, readable display for notes. Pattern may be extended to other note features.   |
| 2025-05-26 (AI Update)     | Refactored `ProjectDashboardClient.tsx` into modular section components (`ManuscriptSection`, `OutlineSection`, `CharactersSection`, `WorldNotesSection`), each with its own data hook and encapsulated state/logic. Introduced `ProjectDataContext` for shared project-wide data. | To improve maintainability, testability, and scalability of the dashboard, reduce cross-section coupling, and enable faster feature development.    |
| ... (previous entries) ... | ...                                                                                                                                                                                                                                                                                | ...                                                                                                                                                 |
| YYYY-MM-DD (AI Update)     | Implemented `SiteSettingsClient` for AI Model management.                                                                                                                                                                                                                          | Provide users/admins a way to configure available AI models.                                                                                        |
| YYYY-MM-DD (AI Update)     | Added `tool_model` table and API.                                                                                                                                                                                                                                                  | To map abstract tool names (e.g., "summarizer") to specific AI models, allowing flexibility.                                                        |
| YYYY-MM-DD (AI Update)     | Integrated `snowgander` via `lib/data/chat.ts` and UI components (`AISidePanel`, `AIToolButton`).                                                                                                                                                                                  | To enable actual AI interactions based on configured models and prompts.                                                                            |
| YYYY-MM-DD (AI Update)     | Developed initial Outline UI (`ProjectSynopsisEditor`, `ChapterSceneOutlineList`) and modals for scene characters/tags.                                                                                                                                                            | To provide the user interface for the refactored outlining feature.                                                                                 |
| YYYY-MM-DD (AI Update)     | Added API routes for managing Scene-Character and Scene-Tag relationships.                                                                                                                                                                                                         | To support the linking of characters and tags to scenes, essential for detailed outlining and manuscript organization.                              |
| YYYY-MM-DD (AI Update)     | Implemented password reset and update password flows.                                                                                                                                                                                                                              | To provide full authentication lifecycle management.                                                                                                |
| 2025-05-24 (AI Update)     | Implemented full CRUD UI for AI Vendors in Site Settings, including modals and confirmation dialogs, matching the AI Model management pattern.                                                                                                                                     | To allow robust configuration of AI Vendors, a prerequisite for advanced AI integration and model management.                                       |
| 2025-05-24 (AI Update)     | Implemented full CRUD UI for AI Prompts in Site Settings, including modals and confirmation dialogs, matching the AI Model and Vendor pattern.                                                                                                                                     | To allow robust configuration of AI Prompts, a prerequisite for advanced AI tool and system prompt management.                                      |
| 2025-05-24 (AI Update)     | **Outline Section - Synopsis View**: Implemented display and editing of project log line and one-page synopsis using `ProjectSynopsisEditor`. Added basic display of character names/nicknames in `CharacterCardQuickViewList` with loading state.                                 | To bring the Synopsis sub-view of the Outline section to life, enabling users to manage high-level project summaries and see associated characters. |
| 2025-05-24 (AI Update)     | Implemented project deletion from the homepage.                                                                                                                                                                                                                                    | To provide users with a direct and intuitive way to manage and remove their projects from the main application entry point.                         |
| 2025-05-25 (AI Update)     | Implemented "Edit Project Details" modal.                                                                                                                                                                                                                                          | To allow users to modify core project details (title, genre, description, target word count) after project creation, enhancing project management.  |
| 2025-05-25 (AI Update)     | Implemented AI-assisted one-page synopsis generation.                                                                                                                                                                                                                              | To provide AI assistance for generating comprehensive one-page synopses, leveraging existing project context.                                       |
| 2025-05-25 (AI Update)     | Overhauled scene tag system to a two-tiered model: added `primary_category` ENUM to scenes and global tags via join table; updated backend, data layer, and UI; separated tag management from direct scene updates.                                                                | To enable more flexible, organized scene categorization and tagging, improve data integrity, and support advanced outlining and filtering.          |

================
File: memory-bank/activeContext.md
================
# Active Context

## Current Work Focus

### Outline Creator Implementation (2025-05-30)

- **Completed**:
  - JSON structure definition and interfaces
  - System prompt engineering for outline generation
  - Backend logic for AI interaction and parsing
  - Entity creation from parsed outline
  - UI integration in OutlineSection
  - Comprehensive testing with various synopses
  - Prompt refinement based on testing
- **Pending Items**:
  - User feedback collection

## Current Work Focus

_(Updated: 2025-05-26 (AI-Generated Update))_

**World Notes Feature Revamp (Markdown Viewer & Edit Toggle):**

- The World Notes section now defaults to a static, Markdown-rendered view of each note, with an "Edit" button to switch to the familiar editor.
- State management for view/edit mode is handled in `useWorldNotesData`, with new state and handlers (`isEditingSelectedNote`, `enableEditMode`, `disableEditMode`).
- The new `WorldNoteViewer` component displays note content using Markdown, with clear UI separation from the editor.
- The main WorldNotesSection conditionally renders either the viewer or the editor based on the current mode, ensuring seamless transitions and correct state resets on note selection or deletion.
- The editor now includes a "Cancel" button and improved save/cancel flow, ensuring edits are only applied when explicitly saved.
- All flows (view, edit, create, delete, edge cases) have been tested for correctness, UX clarity, and error handling.
- This pattern of toggling between static Markdown view and edit mode may be extended to other note-like features for improved UX consistency.

**Major Project Dashboard Refactor Complete (Phases 0–8):**

- The monolithic `ProjectDashboardClient.tsx` has been fully refactored into a modular, maintainable architecture:

  - Each dashboard section (Manuscript, Outline, Characters, World Notes) is now a self-contained component in `components/dashboard/sections/`, responsible for its own UI and state.
  - Each section uses a dedicated custom data hook in `hooks/dashboard/` (e.g., `useManuscriptData`, `useCharactersData`, etc.) for all data fetching, state, and handlers.
  - Shared project-wide data (e.g., all characters, all scene tags) is now managed by a new `ProjectDataContext` (`contexts/ProjectDataContext.tsx`), which provides context and hooks for section components.
  - All state, effects, and handlers related to section data have been removed from `ProjectDashboardClient.tsx`, which now simply renders the section components and provides the context.
  - All modals and detail panels are now managed within their respective section components, ensuring encapsulation and reducing cross-section coupling.
  - The new structure enables easier testing, maintenance, and future feature development.

- **Cleanup and Bugfixes (Phases 7 & 8):**

  - TypeScript errors (e.g., missing exports for `UpdateSceneValues`) have been resolved.
  - Unused variables and imports have been removed across all affected files.
  - All `useEffect` and `useCallback` dependency arrays have been audited and corrected.
  - Import paths have been verified and fixed.
  - The infinite character query loop in OutlineSection has been fixed by tracking fetch attempts per project.
  - The project word count in `AppHeader` now updates in real time after scene edits via `router.refresh()`.
  - The optional character image field is now correctly handled as nullable/optional in `CreateCharacterModal`.
  - All known dashboard-related bugs from the previous progress log have been addressed.

- **Testing and Review:**
  - All dashboard sections have been tested for CRUD, navigation, and data consistency.
  - Drag-and-drop scene reordering, AI-assisted outline/synopsis generation, and all modal flows have been verified.
  - The new architecture has been reviewed for prop consistency, hook usage, and modularity.

**The scene tag system has been overhauled to a two-tiered model: each scene now has a primary category (ENUM) and can be assigned multiple global tags (managed via a join table). Ongoing work includes refining tag management UI, API separation, and thorough testing of the new system.**

## Recent Changes

- **World Notes Feature Revamp (2025-05-26):**

  - Added `isEditingSelectedNote` state and edit mode handlers to `useWorldNotesData` for managing view/edit state.
  - Created `WorldNoteViewer` component for static, Markdown-rendered note display with an "Edit" button.
  - Updated `components/world-notes/index.ts` to export the new viewer.
  - Modified `WorldNotesSection` to conditionally render the viewer or editor based on edit state, with correct keying and state reset logic.
  - Enhanced `WorldNoteEditor` to support a "Cancel" button and ensure save/cancel flows correctly switch modes and reset form state.
  - Verified all flows: viewing, editing, creating, deleting notes, and edge cases (empty content/category, rapid switching, unsaved edits).
  - Ensured clear separation of view and edit UI, robust state management, and user-friendly error handling.
  - Pattern established for toggling between Markdown view and edit mode for note-like features.

- **Major Project Dashboard Refactor (2025-05-26):**

  - Decomposed `ProjectDashboardClient.tsx` into modular section components: `ManuscriptSection`, `OutlineSection`, `CharactersSection`, and `WorldNotesSection`, each in `components/dashboard/sections/`.
  - Each section now manages its own state and data via a dedicated custom hook in `hooks/dashboard/` (e.g., `useManuscriptData`, `useCharactersData`, etc.).
  - Introduced `ProjectDataContext` (`contexts/ProjectDataContext.tsx`) to provide shared project-wide data (e.g., all characters, all scene tags) to all sections.
  - Removed all monolithic state, effects, and handlers from `ProjectDashboardClient.tsx`, which now simply renders the section components and provides context.
  - All modals and detail panels are now managed within their respective section components.
  - Performed comprehensive cleanup: removed unused variables/imports, fixed all TypeScript errors, audited all `useEffect`/`useCallback` dependencies, and verified all import paths.
  - Fixed key bugs: infinite character query loop in OutlineSection, real-time word count update in `AppHeader`, and optional character image handling in `CreateCharacterModal`.
  - All dashboard sections and flows have been tested for CRUD, navigation, and data consistency.

- **Two-Tiered Scene Tag System Overhaul (2025-05-25):**

  - Added `primary_category` ENUM and column to the `scenes` table via migration.
  - Seeded predefined global scene tags in `supabase/seed.sql`.
  - Updated backend types (`PrimarySceneCategory`), Zod schemas, and data layer to support `primary_category` and global tags.
  - Modified API routes for scene creation and update to handle `primary_category` and decoupled tag management from direct scene updates (tags now managed via join table).
  - Enhanced UI components (`CreateSceneModal`, `ChapterSceneOutlineList`, etc.) to support primary category selection and display, and improved tag selection UX.
  - Addressed issues with tag_ids not being a direct column and ensured correct handling in data and API layers.
  - Ongoing: Finalizing dedicated tag management routes/components and comprehensive testing.

<!-- (rest of file unchanged) -->




================================================================
End of Codebase
================================================================
